/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "Wx100AudioProcessor.h"
#include "Wx100Editor.h"

//==============================================================================
Wx100AudioProcessor::Wx100AudioProcessor()
{
    for (int i = 0; i < numOperators; ++i)
    {
        parameters[AMP_1 + i] = 0.0;
        parameters[TUNING_1 + i] = 0.0;
        parameters[ATTACK_1 + i] = 0.0;
        parameters[DECAY_1 + i] = 0.0;
        parameters[SUSTAIN_1 + i] = 1.0;
        parameters[RELEASE_1 + i] = 0.0;
    }
    synth.addSound(new Wx100SynthSound());
    synth.addVoice(new Wx100SynthVoice(parameters));
    synth.setNoteStealingEnabled(true);
    initAllParameters();
}

Wx100AudioProcessor::~Wx100AudioProcessor()
{
}

void Wx100AudioProcessor::initParameters()
{
    for (int i = 0; i < numOperators; ++i)
    {
        char ampName[30];
        sprintf(ampName, "Amp_%i", i + 1);
        addFloatParam(AMP_1 + i, ampName, true, SAVE, &parameters[AMP_1 + i], 0.00, 1.0);
    }
    
    for (int i = 0; i < numOperators; ++i)
    {
        char tuningName[30];
        sprintf(tuningName, "Tuning_%i", i + 1);
        addFloatParam(TUNING_1 + i, tuningName, true, SAVE, &parameters[TUNING_1 + i], 0.00, 1.0);
    }
    
    for (int i = 0; i < numOperators; ++i)
    {
        char attackName[30];
        sprintf(attackName, "Attack_%i", i + 1);
        addFloatParam(ATTACK_1 + i, attackName, true, SAVE, &parameters[ATTACK_1 + i], 0.00, 1.0);
    }
    
    for (int i = 0; i < numOperators; ++i)
    {
        char decayName[30];
        sprintf(decayName, "Decay_%i", i + 1);
        addFloatParam(DECAY_1 + i, decayName, true, SAVE, &parameters[DECAY_1 + i], 0.00, 1.0);
    }
    
    for (int i = 0; i < numOperators; ++i)
    {
        char sustainName[30];
        sprintf(sustainName, "Sustain_%i", i + 1);
        addFloatParam(SUSTAIN_1 + i, sustainName, true, SAVE, &parameters[SUSTAIN_1 + i], 0.00, 1.0);
    }
    
    for (int i = 0; i < numOperators; ++i)
    {
        char releaseName[30];
        sprintf(releaseName, "Release_%i", i + 1);
        addFloatParam(RELEASE_1 + i, releaseName, true, SAVE, &parameters[RELEASE_1 + i], 0.00, 1.0);
    }
}

void Wx100AudioProcessor::setParameter(int index, float value)
{
    parameters[index] = value;
}

const String Wx100AudioProcessor::getParameterText (int index)
{
    return String();
}

const String Wx100AudioProcessor::getInputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

const String Wx100AudioProcessor::getOutputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

bool Wx100AudioProcessor::isInputChannelStereoPair (int index) const
{
    return true;
}

bool Wx100AudioProcessor::isOutputChannelStereoPair (int index) const
{
    return true;
}

double Wx100AudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int Wx100AudioProcessor::getNumPrograms()
{
    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
                // so this should be at least 1, even if you're not really implementing programs.
}

int Wx100AudioProcessor::getCurrentProgram()
{
    return 0;
}

void Wx100AudioProcessor::setCurrentProgram (int index)
{
}

const String Wx100AudioProcessor::getProgramName (int index)
{
    return String();
}

void Wx100AudioProcessor::changeProgramName (int index, const String& newName)
{
}


void Wx100AudioProcessor::runAfterParamChange(int paramIndex,UpdateFromFlags updateFromFlag)
{
    getParam(paramIndex)->updateHostAndUi(false,UPDATE_FROM_PROCESSOR);
}

void Wx100AudioProcessor::runAfterParamGroupUpdate()
{
    for (int i = 0; i < NUMBER_OF_PARAMETERS; ++i)
        getParam(AMP_1 + i)->updateHostAndUi(false,UPDATE_FROM_PROCESSOR);
}

//==============================================================================
void Wx100AudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    synth.setCurrentPlaybackSampleRate(sampleRate);
    // Use this method as the place to do any pre-playback
    // initialisation that you need..
}

void Wx100AudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
}

void Wx100AudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
    buffer.clear();
    int numSamples = buffer.getNumSamples();
    keyboardState.processNextMidiBuffer(midiMessages, 0, numSamples, true);
    synth.renderNextBlock(buffer, midiMessages, 0, numSamples);
}

//==============================================================================
bool Wx100AudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* Wx100AudioProcessor::createEditor()
{
    return new Wx100AudioProcessorEditor (*this);
}

//==============================================================================
void Wx100AudioProcessor::getStateInformation (MemoryBlock& destData)
{
    //Save all the parameter values into an XML tag with name JucePlugin_Name.
    XmlElement xml(JucePlugin_Name);
    saveXml(&xml,false,true);
    //Save it as binary data
    copyXmlToBinary (xml, destData);
}

void Wx100AudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    //Convert the binary data saved in getStateInformation(...) back into XML.
    ScopedPointer<XmlElement> xmlState (getXmlFromBinary (data, sizeInBytes));
    
    // Check that it is valid XML and that the tag has name JucePlugin_Name.
    if (xmlState != 0 && xmlState->getTagName()==JucePlugin_Name){
        //Preload XML values into memory
        readXml(xmlState, true);
        //Update the parameter values from the preloaded XML values
        updateProcessorHostAndUiFromXml(true,true,true);
    }
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new Wx100AudioProcessor();
}
